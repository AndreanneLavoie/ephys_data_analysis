function vs_timepoints = extract_signal_time(time_file_name, analog_file_name, filedir, threshold, digfilter_winT, sampling_rate) %maybe instead take the filename and raw data dir path as input and call other functions inside
    %Convert analog trace to digital, based on thereshold of 0.3V
    %Return each time point in which the digital signal goes from 0 to 1;
    
    %INPUT: 
    %time_file_name - 'time.dat' generated by Intan
    %if digfilter_winT == 0, digfilter function will not be applied
    %for stimulus with fast rising/falling phases, digfilter_winT = 0.0006
    %for stimulus with fast rising/falling phases, digfilter_winT = 0.001
    
    if nargin < 6
        sampling_rate = 30000;
    end

    %import raw data into matlab, includes time and one analog input (vs timing, led timing, behviour, camera timing) 
    t = importIntanTime(time_file_name, filedir, sampling_rate); %ADD DIR
    deltat=mean(diff(t)); %in sec
    digfilter_winsize=round(digfilter_winT/deltat);
    analog_signal = importIntanAnalog(analog_file_name, filedir); %ADD DIR

    analog_signal=medfilt1(analog_signal,digfilter_winsize); % use median filter to remove spikes, which works much faster than digital filter
    dig_threshold=analog_signal>threshold;
    
    %smooth out curve from analog signals using digital filter; will only run if digfilter_winT
    %is non 0; 
    %digital filter does not change rising phase precision, but affects
    %falling phase
    
%     if abs(digfilter_winT) > 10e-8
%     %vs_timepoints = for all elements in v01, if i in v10 != i+1 and i==0, save value of t[i+1];
%         digtemp=zeros(length(dig_threshold), digfilter_winsize);
%         digtemp(:,1)=dig_threshold;
%         for i=1:(digfilter_winsize-1)
%             digtemp(:,i+1)=circshift(dig_threshold, i*-1);
%         end
%         dig_threshold=all(digtemp, 2); 
%     end

    %identify timepoints when there is change (ie take derrivative 1st)
    der1st=diff(dig_threshold);  
    der1st=[0; der1st]; %add another value at the front (0) because derrivative compares two value and will be missing one at the end

    vs_start=t((der1st>0.5));
    vs_end =t((der1st<-0.5));

    vs_timepoints=[vs_start vs_end vs_end-vs_start];

%     figure
%     plot(t, analog_signal)
end